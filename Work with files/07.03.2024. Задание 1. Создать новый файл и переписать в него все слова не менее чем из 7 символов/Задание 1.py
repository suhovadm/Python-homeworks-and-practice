# Задача: дан текстовый файл. Необходимо создать новый файл,
# в который требуется переписать из исходного файла все
# слова, состоящие не менее чем из 7 (семи) букв.

# Открываем первый текстовый файл, даём команду на чтение из него (r - read), задаём префикс f1.
with open('IN.txt', 'r') as f1:

    # Открываем второй текстовый файл, даём команду на запись (w - write), задаём префикс f2.
    with open('OUT.txt', 'w') as f2:

        # Заводим первую случайную переменную, говорим, что нужно прочитать всё из файла f1.
        content = f1.read()

        # Заводим вторую случайную переменную, говорим, что у первой переменной нужно
        # разделить слова и убрать пробелы перед оными. То есть, подгоняем первый файл ко второму.
        # \n в скобках перенесёт все пробелы из первого файла во второй.

        # words = content.split() # просто разбивает строку с разделителями на подстроки.
        # words = content.rsplit # разделяет строку и убирает пробелы перед словами.

        words = content.rsplit('\n')

        # Запускаем цикл for, проходимся по всем словам в файле.
        for word in words:

            # Перебирает все слова в файле и отбрасывает те, в которых больше 7 символов.
            if len(word) <= 7:

                # Записывает содержимое во второй файл по префиксу f2.
                f2.write(word + '\n')

# Здесь stream.close() в конце писать не нужно.
# Почему? В данном коде используется конструкция with open(...) as которая автоматически управляет
# ресурсами файла. Это означает, что как только блок with завершает выполнение, интерпретатор Python
# автоматиечски закрывает файл, вызывая метод close() у файла.

# То есть...
# with open('IN.txt', 'r') as f1 - открывает файл для чтения и гарантирует его закрытие после выхода из блока.
# with open('OUT.txt', 'w') as f2 - открывает файл для записи и также гарантирует его закрытие по завершении блока.
# Поэтому писать stream.close() или f1.close() и f2.close() вручную в конце не нужно, так как это делается
# автоматически. Это одно из преимуществ использования контекстного менеджера with, который обеспечивает
# безопасное и удобное управление ресурсами, предотвращая возможные утечки или блокировки файлов.