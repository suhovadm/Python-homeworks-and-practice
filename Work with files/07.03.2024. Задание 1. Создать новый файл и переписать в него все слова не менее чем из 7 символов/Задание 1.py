# Задача: дан текстовый файл. Необходимо создать новый файл,
# в который требуется переписать из исходного файла все
# слова, состоящие не менее чем из 7 (семи) букв.

# Открываем первый текстовый файл, даём команду на чтение из него (r - read), задаём префикс f1.
with open('IN.txt', 'r') as f1:

    # Открываем второй текстовый файл, даём команду на запись (w - write), задаём префикс f2.
    with open('OUT.txt', 'w') as f2:

        # Заводим первую случайную переменную, говорим, что нужно прочитать всё из файла f1.
        content = f1.read()

        # Метод split() без аргументов разбивает строку content по любым пробелам (пробелы, табы, переносы).
        # В результате получается список слов words.
        # Например, строка "Привет, как дела?" станет списком: ["Привет,", "как", "дела?"]
        words = content.split()

        # Запускаем цикл for, проходимся по каждому слову.
        for word in words:

            # Убираем возможные знаки пунктуации и переводим слово в нижний регистр.
            # Можно использовать strip() для удаления знаков пунктуации.
            clean_word = word.strip('.,!?;:"\'()[]{}')
            # Проверяем длину слова: не менее 7 букв.
            if len(clean_word) >= 7:

                # Записывает слово (word) в файл по префиксу f2, добавляя перевод строки.
                f2.write(word + '\n')

# Здесь stream.close() в конце писать не нужно.
# Почему? В данном коде используется конструкция with open(...) as которая автоматически управляет
# ресурсами файла. Это означает, что как только блок with завершает выполнение, интерпретатор Python
# автоматиечски закрывает файл, вызывая метод close() у файла.

# То есть...
# with open('IN.txt', 'r') as f1 - открывает файл для чтения и гарантирует его закрытие после выхода из блока.
# with open('OUT.txt', 'w') as f2 - открывает файл для записи и также гарантирует его закрытие по завершении блока.
# Поэтому писать stream.close() или f1.close() и f2.close() вручную в конце не нужно, так как это делается
# автоматически. Это одно из преимуществ использования контекстного менеджера with, который обеспечивает
# безопасное и удобное управление ресурсами, предотвращая возможные утечки или блокировки файлов.