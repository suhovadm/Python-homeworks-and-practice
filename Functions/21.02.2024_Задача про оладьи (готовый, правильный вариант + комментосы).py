# Задача про оладьи (панкейки).
# 1. Найти блин с наибольшим радиусом.
# 2. Перевернуть стопку так, чтобы блин с наибольшим радиусом оказался наверху.
# 3. Вернуть всю стопку, чтобы наибольший блин остался внизу.
# 4. Повторить сие действие, уменьшая ассортимент блинов.

# Заводим функцию, которая принимает функцию arr - радиусы блинов, и возвращает
# список операций, которые нужно выполнить, чтобы отсортировать стопку.
def pancakes_sort(arr):

    # Заводим первую вложенную функцию.
    # Что делает? Находит индекс блина с наибольшим радиусом в первых n элементах массива.
    def find_largest_index(arr, n):

            # Переменная i хранит текущий индекс "самого большого" блина.
            i = 0

            # Цикл перебирает все элементы от 0 до n.
            for j in range(n):

                # Условите. Оно проверяет был ли текущий блин больше найденного ранее
                # и обновляет i.
                if arr[j] > arr[i]:
                    i = j

            # Возвращает индекс элемента с максимальным радиусом среди первых n.
            return i

    # Заводим вторую вложенную функцию. Это функция переворота блинчика.
    def flip(arr, k):

        # Берём срез первых k элементов и переворачиваем его.
        # Данный скрипт переворачивает первые k элементов, а не всю стопку целиком.
        # arr[:k][::-1] - берёт срез первых k элементов и переворачивает его.
        # + arr[k:] - добавляет оставшуюся часть массива без изменений.
        return arr[:k][::-1] + arr[k:]

    # Заводим пустой список. В result-e сохраняются операции.
    result = []

    # Текущий размер "стопки". Изначально вся стопка.
    n = len(arr)

    # Пока n > 1: повторяем, пока не останется один блин - то есть пока не отсортируем всё.
    while n > 1:

        # Что происходит внутри цикла?

        # Поиск наибольшего блина в текущей части.
        # Находим индекс наибольшего радиуса блина в первых n элементов.
        i = find_largest_index(arr, n)

        # Проверка необходимости переворота.
        # Если наибольший блин уже в нужной позиции (в конце текущего участка), ничего не делаем.
        # Если нет - нужно его переместить.
        if i < n - 1:

            # Перемещение наибольшего блина наверх (если он не наверху).

            # Переворачиваем первые i+1 элементов, чтобы блин с максимальным радиусом оказался наверху.
            arr = flip(arr, i+1)

            # Записываем операцию i+1 в список result.
            result.append(i+1)

            # Перемещение наибольшего блина в конец текущей части.

            # Переворачиваем первую n элементов, чтобы максимальный блин оказался внизу текущей области.
            arr = flip(arr, n)

            # Записываем операцию n в список result.
            result.append(n)

        # Уменьшение n.
        # После того как самый большой блин "уже" в конце текущей части, уменьшаем размер n,
        # чтобы далее сортировать оставшуюся часть.
        n -= 1

    # Небольшой итог:
    # Проходя по всему циклу, алгоритм постепенно "выводит" самый большой блин в конец,
    # затем, уменьшает рассматриваемую часть и повторяет.
    # В результате, после завершения цикла, весь массив будет отсортирован по возрастанию радиусов.

    # Возврат результата.
    # Возвращаем список операций - последовательность k, на которые нужно перевернуть, чтобы
    # выполнить сортировку.
    return result

# Важно заметить, что после вызова pancakes_sort(pancakes) список pancakes не изменится,
# потому что внутри arr - копия. Поэтому оригинальный список остаётся неизменным.

# В данном случае, мы получим список операций oper, а исходный список pancakes - останется без изменений.

# Выводим результаты:

# Исходный список блинов.
pancakes = [3, 1, 4, 5, 9, 6]

# Получаем список операций для сортировки.
oper = pancakes_sort(pancakes)

# Создаём копию списка блинов для применения операций.
sorted_pancakes = pancakes.copy()

# Определяем функцию flip для применения к списку.
def flip(arr, k):
    return arr[:k][::-1] + arr[k:]

# Применяем каждую операцию из списка.
for k in oper:
    sorted_pancakes = flip(sorted_pancakes, k)

# Выводим списки:

# Изначальный список блинов.
print('Изначальный список блинов:', pancakes)

# Отсортированный список блинов.
print('Отсортированный список блинов:', sorted_pancakes)

# Количество операций.
print('Операции:', oper)