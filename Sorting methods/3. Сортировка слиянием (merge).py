# 3.
# Метод сортировки слиянием.

# Приглашение к вводу команды.
# В данном случае, происходит преобразование символов в целые числа, то есть, мы вводим не символы через обычный
# input, а именно числа с помощью map(int, input ...) Это обеспечивает нам правильную сортировку!
value3 = list(map(int, input('Введите список целых чисел (можно слитно, можно через пробел):~$ ').replace(' ', '')))

# Заводим функцию с именем merge - слияние.
def merge(left_list, right_list):
# В качестве параметров функции передаём 2 аргумента - левый список и правый список.

    # Переменные.
	sorted_list = [] # Создаём пустой список, в который по очереди добавляются элементы.
	left_list_index = 0 # Индекс для отслеживания текущего элемента в левом списке.
	right_list_index = 0 # Индекс для отслеживания текущего элемента в правом списке.

# Заводим переменные для определения количества элементов в каждом списке, в правом и в левом.
	left_list_length, right_list_length = len(left_list), len(right_list)

# Заводим цикл, который повторяется столько раз, сколько всего элементов (сумма длин двух списков).
	for i in range(left_list_length + right_list_length):
		
		# Эта проверка гарантирует нам, что сравнение элементов происходит только тогда, когда
		# оба списка ещё содержат элементы, доступные для сравнения.
		if left_list_index < left_list_length and right_list_index < right_list_length:
			
			# Сравниваем первые элементы в начале каждого списка.
			# Если первый элемент левого подспика меньше, добавляем его
			# в отсортированный список.
			if left_list[left_list_index] <= right_list[right_list_index]:
				sorted_list.append(left_list[left_list_index])
				left_list_index += 1

			# Если первый элемент правого списка меньше, то добавляем его
			# в отсортированный список.
			else:
				sorted_list.append(right_list[right_list_index])
				right_list_index += 1

		# Если достигнут конец левого списка, элементы правого списка
		# добавляются в конец результирующего списка.
		elif left_list_index == left_list_length:
			sorted_list.append(right_list[right_list_index])
			right_list_index += 1

		# Если достигнут конец правого списка, элементы левого списка
		# добавляются в конец результирующего списка.
		elif right_list_index == right_list_length:
			sorted_list.append(left_list[left_list_index])
			left_list_index += 1

	# После завершения цикла возвращается объединённый отсортированный список.
	return sorted_list

# Заводим функцию merge_sort, передаём в неё аргумент list1.
# Это рекурсивная функция, реализующая алгоритм сортировки слиянием.
# Если длина списка равна или меньше 1, то он уже отсортирован, и функция возвращает его без изменений.
def merge_sort(list1):
	# Возвращаем список, если в нём 1 элемент.
	if len(list1) <= 1:
		return list1

	# Находим середину списка.
    # Для того, чтобы найти середину списка используем деление без остатка.
    # Индексы должны быть integer, то есть целочисленные.
	mid = len(list1) // 2 # mid - это переменная, обозначающая середину списка (middle).

	# Делим списки на две части - левую и правую.
	# Каждая часть передаётся рекурсивно в merge_sort, что позволяет разбить список
	# по одному элементу.
	left_list = merge_sort(list1[:mid]) # Левый список. [:mid] - срез сначала (слева).
	right_list = merge_sort(list1[mid:]) # Правый список. [mid:] - срез сконца (справа).

	# Объединяем и возвращаем один список функцией merge.
	return merge(left_list, right_list)

# Заводим переменную равную value3, т.е. значению, которое ввёл пользователь.
random_list_merge = value3

# Вывод на экран.
print('Список, отсортированный методом слияния.')

# Запускаем функцию слияния (merge_sort).
# В данном случае, она запускается через переменную random_list_merge.
# Если запустить её без переменной random_list_merge, покажет мешанину из цифр.
random_list_merge = merge_sort(random_list_merge)

# Принтуем random_list_merge на экран.
print(random_list_merge)
print('-'*80)