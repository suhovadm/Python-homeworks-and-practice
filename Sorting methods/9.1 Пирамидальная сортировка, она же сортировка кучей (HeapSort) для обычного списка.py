# 9.1.
# Метод пирамидальной сортировки. Сортировка кучей.
# Тот же самый вариант, но для статического списка, а не для рандомного.

# --- ЧАСТЬ 1: Определение функции heapify. ---

# Заводим функцию heapify, передаём в неё 3 аргумента - nums, heap_size и root_index.
# nums - это список чисел, который нужно преобразовать.
# heap_size - размер текущей части списка, которая считается кучей.
# root_index - индекс "корня" рассматриваемой части кучи, относительно которого
# и будет происходить сравнение и возможное изменение.
def heapify(nums, heap_size, root_index):

    # Заводим переменную largest равной текущему корневому индексу.
    # В дальнейшем эта переменная будет содержать индекс наибольшего элемента среди корня
    # и его потомков.
    largest = root_index

    # Вычисляем индексы левого и правого потомков текущего узла (используя свойства полного бинарного
    # дерева, хранящегося в списке):
    # left_child - индекс левого дочернего элемента.
    # right_child - индекс правого дочернего элемента.
    left_child = (2 * root_index) + 1
    right_child = (2 * root_index) + 2

    # Если левый потомок корня - это допустимый индекс, а элемент больше,
    # чем текущий наибольший, то обновляем наибольший элемент. Верхушка (root) будет изменяться.
    if left_child < heap_size and nums[left_child] > nums[largest]:
        largest = left_child
    # То же самое и для правого потомка корня.
    if right_child < heap_size and nums[right_child] > nums[largest]:
        largest = right_child
    # Если наибольший элемент уже не корневой, они меняются местами.
    # То есть, если после сравнения largest отличается от root_index, значит, найден
    # более крупный элемент среди корня и его потомков.
    # Тогда: меняем местами элементы по индексам root_index и largest.
    # После этого, рекурсивно вызываем heapify, чтобы убедиться, что после обмена
    # структура кучи сохраняется, потому что поменявшиеся элементы могут нарушить свойства
    # кучи в поддеревьях.
    if largest != root_index:
        nums[root_index], nums[largest] = nums[largest], nums[root_index]
        heapify(nums, heap_size, largest) # <--- Рекурсивный вызвов heapify...

# --- ЧАСТЬ 2: Объявление функции heap_sort. ---

# Создаём Max Heap из списка.
# 2-й аргумент означает остановку алгоритма перед элементом -1, то есть перед первым элементом списка
# 3-й аргумент означает повторный проход по списку в обратном направлении, уменьшая счётчик i на 1

# Заводим функцию heap_sort, передаём в неё 1 аргумент nums.
# Эта функция сортирует список nums с помощью алгоритма кучи.
# n - это длина списка, общее число элементов.
def heap_sort(nums):
    n = len(nums)

# --- Построение кучи. ---
# Перемещаем корень Max Heap в самый конец списка.

    # Цикл for идёт с n до 0 включительно (шаг -1).
    # Для каждого i вызывается heapify, чтобы превратить список в кучу.

    # Здесь есть небольшое замечание: в диапазоне range(n, -1, -1) стоит использовать
    # range(n // 2, -1, -1), потому что только узлы с индексами до n // 2 - 1 являются
    # внутренними узлами, остальные - листовыми. Но в данном коде строится куча за счёт
    # обхода всего диапазона, что тоже работает, хотя и менее эффективно.

    for i in range(n // 2, -1, -1):
        heapify(nums, n, i)

    # --- Основной цикл сортировки! ---

    # Этот цикл идёт с конца списка к началу (от n-1 до 1).
    for i in range(n - 1, 0, -1):

        # На каждом шаге меняем местами первый элемент nums[0] (максимальный в куче) с текущим элементом nums[i].
        # Это "вынимает" максимум из кучи и помещает его в конец массива.
        nums[i], nums[0] = nums[0], nums[i]

        # Затем вызывается heapify для уменьшенной части массива (heap_size = i), чтобы восстановить свойства
        # кучи в оставшейся части.
        heapify(nums, i, 0)

# В данном примере создаём обычный список случайных чисел.
list1 = [7, 2, 5, 6, 9, 14, 28, 71, 15, 90, 91, 11, 12]

# Вызываем функцию heap_sort, которая отсортирует список list1 по возрастанию с помощью алгоритма кучи.
heap_sort(list1)

# Вывод на экран отсортированного списка.
print(list1)